package gov.nist.microanalysis.EPQLibrary;

import java.util.Arrays;
import java.util.List;

/**
 * <p>
 * CharacteristicXRayGeneration computes the (fractional) quantity of x-rays of
 * the specified transition generated by an electron of the specified energy in
 * the specified density of the appropriate atoms. The type of atoms is
 * specified by the XRayTransition object.
 * </p>
 * <p>
 * Copyright: Pursuant to title 17 Section 105 of the United States Code this
 * software is not subject to copyright protection and is in the public domain
 * </p>
 * <p>
 * Institution: National Institute of Standards and Technology
 * </p>
 * 
 * @author nritchie
 * @version 1.0
 */
public abstract class CharacteristicXRayGeneration
   extends AlgorithmClass {

   /**
    * Constructs a CharacteristicXRayGeneration algorithm instance
    * 
    * @param name
    * @param ref
    */
   protected CharacteristicXRayGeneration(String name, String ref) {
      super("Characteristic x-ray generation", name, ref);
   }

   /**
    * getAllImplementations
    * 
    * @return List
    * @see gov.nist.microanalysis.EPQLibrary.AlgorithmClass#getAllImplementations()
    */
   @Override
   public List<AlgorithmClass> getAllImplementations() {
      return Arrays.asList(new AlgorithmClass[] {
         NWMR2005a
      });
   }

   /**
    * initializeDefaultStrategy
    * 
    * @see gov.nist.microanalysis.EPQLibrary.AlgorithmClass#initializeDefaultStrategy()
    */
   @Override
   protected void initializeDefaultStrategy() {
      addDefaultAlgorithm(AbsoluteIonizationCrossSection.class, AbsoluteIonizationCrossSection.Casnati82);
   }

   abstract public double compute(XRayTransition xrt, double kE, double atomsPerCC);

   static public class DefaultCharacteristicXRayGeneration
      extends CharacteristicXRayGeneration {
      DefaultCharacteristicXRayGeneration() {
         super("NWMR 2005a", "Cobbled together from various sources");
      }

      /**
       * Computes the generated x-ray intensity. I try to make good use of the
       * information I have at my disposal. Fluorescence yields are available on
       * a per shell basis for the K and L-shells. Only the mean fluorescence is
       * available for the M-shell. Line weights are also an issue. The line
       * weights are reasonably well known for K &amp; L-shell but less well
       * known for M-shell.
       * 
       * @param xrt The x-ray transition of interest
       * @param kE The electron energy in Joules
       * @param atomDensity - The atomic density in atoms per cubic meter
       * @return The generated x-ray intensity
       * @see gov.nist.microanalysis.EPQLibrary.CharacteristicXRayGeneration#compute(gov.nist.microanalysis.EPQLibrary.XRayTransition,
       *      double, double)
       */
      @Override
      public double compute(XRayTransition xrt, double kE, double atomDensity) {
         final AbsoluteIonizationCrossSection icx = (AbsoluteIonizationCrossSection) getAlgorithm(AbsoluteIonizationCrossSection.class);
         double res = 0.0;
         final AtomicShell dest = xrt.getDestination();
         if(kE > dest.getEdgeEnergy()) {
            final double iz = atomDensity * icx.computeShell(dest, kE);
            if(iz > 0.0)
               switch(dest.getShell()) {
                  case AtomicShell.K:
                  case AtomicShell.LI:
                  case AtomicShell.LII:
                  case AtomicShell.LIII:
                     res = iz * AlgorithmUser.getDefaultFluorescenceYield().compute(dest)
                           * xrt.getWeight(XRayTransition.NormalizeDestination);
                     break;
                  case AtomicShell.MI:
                  case AtomicShell.MII:
                  case AtomicShell.MIII:
                  case AtomicShell.MIV:
                  case AtomicShell.MV:
                     final double f = IonizationCrossSection.shellDependence(dest)
                           / IonizationCrossSection.shellDependence(AtomicShell.MV);
                     res = f * iz * AlgorithmUser.getDefaultFluorescenceYieldMean().compute(dest)
                           * xrt.getWeight(XRayTransition.NormalizeFamily);
                     break;
                  default:
                     assert (false); // res=0.0;
                     break;
               }
         }
         return res;
      }
   }

   static public CharacteristicXRayGeneration NWMR2005a = new DefaultCharacteristicXRayGeneration();
}
